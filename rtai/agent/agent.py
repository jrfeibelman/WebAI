from __future__ import annotations
from time import perf_counter
from typing import List, TYPE_CHECKING
from queue import Queue
from numpy import uint16

if TYPE_CHECKING:
    from rtai.agent.agent_manager import AgentManager

from rtai.agent.abstract_agent import AbstractAgent

from rtai.core.event import Event, EventType
from rtai.utils.logging import info, debug, warn, log_transcript
from rtai.agent.persona import Persona
from rtai.agent.memory.short_memory import ShortTermMemory
from rtai.agent.memory.long_memory import LongTermMemory
from rtai.utils.datetime import datetime, timedelta
from rtai.llm.llm_client import LLMClient
from rtai.agent.cognition.agent_concept import AgentConcept
from rtai.agent.behavior.action import Action
from rtai.agent.behavior.chat import Chat
from rtai.agent.cognition.cognition import Cognition

class Agent(AbstractAgent):
    """
    Class to represent AI Agent with thoughts and actions generated by LLMs

    TODO:
        Questions:
            - What should AI Agents do? Thoughts --> Actions (within context of environment (environment = narration + other AI agents))
            - Is this too simplistic? Should reveries = thoughts or should reveries be multiple thoughts / skills / plans that lead to a given action?

        Implementation
            - add retriever to trigger generating reverie
    
    
    """
    id: uint16 = uint16(0)
    agent_mgr: AbstractAgent
    s_mem: ShortTermMemory
    l_mem : LongTermMemory
    is_sleeping: bool
    conversations: List[Event]
    persona: Persona
    cognition: Cognition
    # String representation of persona for LLM calls
    common_set: str
    agent_queue: Queue


    def __init__(self, agent_mgr: AgentManager, client: LLMClient, file_path: str=""):
        """
        Constructor to create a new agent
        INPUT
            agent_mgr: an Agent Manager reference
            file_path: (optional) file to load personality from
        """
        super().__init__()

        self.agent_mgr: AgentManager = agent_mgr
        self.llm_client: LLMClient = client

        self.conversations: List[Event] = []

        self.agent_queue = Queue()
        self.is_sleeping = False

        Agent.id += 1
        self.id = Agent.id

        if len(file_path) == 0:
            self.persona = Persona.generate_from_file('tests/examples/personas/persona%s.txt' % self.id) # TODO use file_path, use LLM to generate personality???
        else:
            self.persona = Persona.generate_from_file(file_path)

        self.s_mem = ShortTermMemory(self.id, self.persona, self.llm_client, self.agent_mgr.world_clock)
        self.l_mem = LongTermMemory()
        self.cognition = Cognition(self)

        info("Created Agent [%s]" % self.get_name())
    
    def update(self) -> None:
        self.retrieve(self.perceive())
        debug("Agent [%s] finished update()" % (self.get_name()))

    def process_queue(self):
       # debug("Polling Event Queue")
        event: Event = None
        while not self.agent_queue.empty():
            event = self.agent_queue.get(block=False)
                
            debug("Agent [%s] Received event:\n\t%s" % (self.get_name(), event))
            self.process_event(event)

    def process_event(self, event: Event):
        if event.get_event_type() == EventType.ChatEvent:
            self.receive_chat_request(event)
        elif event.get_event_type() == EventType.ActionEvent:
            pass
        else:
            warn("Agent [%s] did not process event: %s" % (self.get_name(), event))

    def reject_chat_request(self, event: Event):
        debug("Agent [%s] rejected chat request from [%s]" % (self.get_name(), event.get_sender()))

    def receive_chat_request(self, event: Event):
        debug("Agent [%s] received chat request [%s] from [%s]" % (self.get_name(), event.get_message().seq_num, event.get_sender()))
    
        if len(self.s_mem.chatting_with) > 0:
            if self.s_mem.chatting_with == event.get_sender():
                # If already chatting with requester, then chose which chat to use based on lowest seq num
                if self.s_mem.current_chat.get_id() > event.get_message().get_id():
                    # Accept received chat, discard owned chat
                    self.agent_mgr.delete_chat(self.s_mem.current_chat)
                    self.initiate_chat(event.get_message(), event.get_sender())
                else:
                    # Accept owned chat, discard received chat
                    debug("Agent [%s] discarded chat request [%s] from [%s]. Using owned chat" % (self.get_name(), event.get_message().seq_num, event.get_sender()))
            # Already chatting
            if self.s_mem.current_chat.get_id() != event.get_message().get_id():
                # If in a chat and its not the chat requested
                self.reject_chat_request(event)
            else:
                # Already registered chat
                pass
        else:
            self.initiate_chat(event.get_message(), event.get_sender())

    def end_chat(self, chat: Chat):
        debug("Agent [%s] ended chat [%s] with [%s]" % (self.get_name(), chat.seq_num, self.s_mem.chatting_with))

    def respond_to_chat(self, chat: Chat):
        debug("Agent [%s] responded to chat [%s] with [%s]" % (self.get_name(), chat.seq_num, self.s_mem.chatting_with))

    def initiate_chat(self, chat: Chat, other_agent_name: str):
        debug("Agent [%s] initiated chat [%s] with [%s]" % (self.get_name(), chat.seq_num, other_agent_name))
        self.s_mem.chatting_with = other_agent_name
        self.s_mem.current_chat = chat
        chat.register_participant(self.get_name())

    def act(self, new_day: bool, first_day: bool=False) -> None:
        """
            1) If start of day, perform daily agenda creation
            2) If current action expired, create new plan 
            3) If you perceived an event that needs to be responded to, generate action or chat (TODO later)
        """
        start_time = perf_counter()

        if new_day or first_day:
             # Creates Planning Thought
            self.cognition.plan(False, new_day, first_day)

        # if action expired, create new agenda/plan
        if self.s_mem.has_action_completed():
            debug("Action [%s] completed at [%s]" % (self.s_mem.current_action.description, self.agent_mgr.world_clock.get_time_str()))
            self.cognition.act()
            
        # TODO later - if perceived event that needs to be responded to (such as chat), generate action or chat
        self.process_queue()

        if len(self.s_mem.chatting_with) > 0:
            self.cognition.chat()

        elapsed_time = perf_counter() - start_time
        debug("Agent [%s] took [%s] ms for act()" % (self.get_name(), elapsed_time * 1000))

    def reflect(self) -> None:
        """
        Reflect --> Create Reveries
        """
        start_time = perf_counter()

        self.cognition.reflect()

        elapsed_time = perf_counter() - start_time
        debug("Agent [%s] took [%s] ms for reflect()" % (self.get_name(), elapsed_time * 1000))

    def update_identity(self) -> None:
        """ * Uses LLM
        TODO
        Implement function to update an agent's identity based on new events that occurred and reveries its developed
        Will be called at start of every day
        Try and moving to a memory class
        """
        pass

    def narration_event_trigger(self, event: Event) -> None:
        """
        Function to receive narration change events from the Narrator
        """
        # self.memory.append(event)
        pass

    def agent_event_trigger(self, event: Event) -> None:
        """
        Function to receive agent events for other agents such as chat requests from agent manager
        """
        pass

    def go_to_sleep(self):
        """
        TODO write function to kick off sleeping logic instead of relying on NewDay event
            - revise identity
            - dream ?
        """
        # Update the agent's identity based on events that occurred and reveries its developed
        self.update_identity()
        # Update the agent's relationships with other agents
        # self.update_relationships()

    def debug_timer(self):
        debug("[DEBUG_TIMER - %s] Private Memory(len=%s):\n%s" % (self.get_name(), len(self.memory), self.memory))

    def __str__(self) -> str:
        return self.get_name()
    
    def get_name(self) -> str:
        return self.persona.get_name()
    
    def get_id(self) -> uint16:
        return self.id
    
    def save_to_file(self) -> str:
        # TODO - should be 2 saves : 1 for state and other for base persona ??
        pass
    
    def load_from_file(self) -> bool:
        pass

    def get_common_set_str(self):
        # TODO just store this as a string
        commonset = ""
        commonset += f"Name: {self.persona.name}\n"
        commonset += f"Age: {self.persona.age}\n"
        commonset += f"Backstory: {self.persona.backstory}\n"
        commonset += f"Occupation: {self.persona.occupation}\n"
        commonset += f"Innate traits: {self.persona.traits}\n"
        commonset += f"Motivations: {self.persona.motivations}\n"
        commonset += f"Relationships: {self.persona.relationships}\n"
        commonset += f"Daily plan requirement: {self.s_mem.daily_plan}\n"
        # commonset += f"Current Date: {self.curr_time.strftime('%A %B %d')}\n"
        return commonset